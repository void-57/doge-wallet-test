<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>RanchiMall Dogecoin Web Wallet - Test Page</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }
      h2 {
        margin-top: 30px;
      }
      input,
      button {
        margin: 5px 0;
        width: 100%;
        padding: 8px;
      }
      .output {
        background: #f5f5f5;
        padding: 10px;
        border: 1px solid #ddd;
        min-height: 40px;
        white-space: pre-wrap;
      }

      #txPagination {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
      }

      #txPagination button {
        padding: 8px 15px;
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      #txPagination button:hover:not(:disabled) {
        background-color: #e0e0e0;
      }

      #txPagination button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #txPageInfo {
        font-size: 0.9em;
        color: #666;
        text-align: center;
        margin-top: 5px;
      }
    </style>

    <script src="doge/lib.dogecoin.js"></script>
    <script src="doge/dogeCrypto.js"></script>
    <script src="doge/dogeBlockchainAPI.js"></script>
  </head>
  <body>
    <h1>RanchiMall Dogecoin Web Wallet - Function Tester</h1>

    <!--  Multi-Chain Address Generation -->
    <h2>Generate Multi-Blockchain Addresses</h2>
    <p></p>
    <button onclick="generateMultiChain()">Generate</button>
    <div id="multiResult" class="output"></div>

    <!-- Recover Address -->
    <h2>Recover Multi-Blockchain Addresses</h2>
    <p>
      Recover all blockchain addresses (DOGE, FLO, BTC, LTC) from a single
      private key
    </p>
    <input
      id="translateWIF"
      placeholder="Enter DOGE / BTC / FLO / LTC private key"
    />
    <button onclick="translateAddress()">Recover</button>
    <div id="translateResult" class="output"></div>

    <!-- Direct Address Translation -->
    <h2>Address-to-Address Translation</h2>
    <p>Convert addresses between blockchains (DOGE, FLO, BTC, LTC)</p>
    <input
      id="addressToTranslate"
      placeholder="Enter DOGE / BTC / FLO / LTC address"
    />
    <button onclick="translateDirectAddress()">Translate</button>
    <div id="directTranslateResult" class="output"></div>

    <!-- Dogecoin Balance Section -->
    <h2>Check Dogecoin Balance</h2>
    <input id="balanceAddress" placeholder="Enter DOGE address" />
    <button onclick="checkDogeBalance()">Check Balance</button>
    <div id="balanceResult" class="output"></div>

    <!-- Dogecoin Transaction History -->
    <h2>Dogecoin Transaction History</h2>
    <input id="txHistoryAddress" placeholder="Enter DOGE address" />
    <button onclick="getDogeTransactions()">Get Transactions</button>
    <div id="txHistoryResult" class="output"></div>
    <div id="txPagination" style="display: none">
      <button id="prevTxButton" onclick="loadPreviousTransactions()">
        &lt; Previous
      </button>
      <button id="nextTxButton" onclick="loadNextTransactions()">
        Next &gt;
      </button>
    </div>
    <div id="txPageInfo"></div>

    <!-- Send Dogecoin -->
    <h2>Send Dogecoin</h2>
    <div>
      <input id="senderAddress" placeholder="Sender's DOGE address" />
      <input
        id="privateKey"
        placeholder="Sender's Private Key"
        type="password"
      />
      <input id="receiverAddress" placeholder="Recipient's DOGE address" />
      <input
        id="sendAmount"
        placeholder="Amount to send (DOGE)"
        type="number"
        step="0.00000001"
        min="1"
      />
      <button onclick="sendDogeRPC()">Send DOGE (RPC)</button>
      <div id="sendResult" class="output"></div>
    </div>

    <script>
      let currentTxOffset = 0;
      const txPerPage = 10;
      let totalTxCount = 0;
      let currentTxAddress = "";

      function generateMultiChain() {
        try {
          const result = floCrypto.generateMultiChain();
          /* Expected format:
           { DOGE: {address, wif}, FLO: {...}, BTC: {...} } */
          document.getElementById("multiResult").innerText = JSON.stringify(
            result,
            null,
            2
          );
        } catch (err) {
          document.getElementById("multiResult").innerText =
            "Error: " + err.message;
        }
      }

      function translateAddress() {
        const wif = document.getElementById("translateWIF").value.trim();
        try {
          const result = floCrypto.generateMultiChain(wif);
          document.getElementById("translateResult").innerText = JSON.stringify(
            result,
            null,
            2
          );
        } catch (err) {
          document.getElementById("translateResult").innerText =
            "Error: " + err.message;
        }
      }

      function translateDirectAddress() {
        const address = document
          .getElementById("addressToTranslate")
          .value.trim();
        try {
          const result = floCrypto.translateAddress(address);
          document.getElementById("directTranslateResult").innerText =
            JSON.stringify(result, null, 2);
        } catch (err) {
          document.getElementById("directTranslateResult").innerText =
            "Error: " + err.message;
        }
      }

      // Dogecoin API Functions
      function checkDogeBalance() {
        const address = document.getElementById("balanceAddress").value.trim();
        if (!address) {
          document.getElementById("balanceResult").innerText =
            "Error: Please enter a Dogecoin address";
          return;
        }

        document.getElementById("balanceResult").innerText = "Loading...";

        floBlockchainAPI
          .getBalance(address)
          .then((balance) => {
            console.log("Balance retrieved:", balance);
            document.getElementById("balanceResult").innerText =
              balance + " DOGE";
          })
          .catch((error) => {
            console.error("Error using getBalance:", error);
          });
      }
      // Transaction History
      function getDogeTransactions() {
        const address = document
          .getElementById("txHistoryAddress")
          .value.trim();
        if (!address) {
          document.getElementById("txHistoryResult").innerText =
            "Error: Please enter a Dogecoin address";
          return;
        }

        currentTxOffset = 0;
        currentTxAddress = address;

        fetchTransactionsWithPagination();
      }

      function fetchTransactionsWithPagination() {
        document.getElementById("txHistoryResult").innerText =
          "Loading... (this may take a moment)";

        document.getElementById("txPagination").style.display = "none";
        document.getElementById("txPageInfo").innerText = "";

        floBlockchainAPI
          .getDogeTransactions(currentTxAddress, {
            limit: txPerPage,
            offset: currentTxOffset,
          })
          .then((result) => {
            if (!result.transactions || result.transactions.length === 0) {
              document.getElementById("txHistoryResult").innerText =
                "No transactions found for this address.";
              return;
            }

            totalTxCount = result.total || 0;

            console.log("All transactions:", result.transactions);

            const displayTransactions = result.transactions.map((tx) => {
              let numericValue = parseFloat(tx.value);
              let valueDisplay = "";
              let txType = "";

              if (numericValue > 0) {
                // Coins received
                valueDisplay = "+" + numericValue.toFixed(8) + " DOGE";
                txType = "ðŸ“¥ Received";
              } else if (numericValue < 0) {
                // Coins sent
                valueDisplay = numericValue.toFixed(8) + " DOGE";
                txType = "ðŸ“¤ Sent";
              } else {
                valueDisplay = numericValue.toFixed(8) + " DOGE (fee)";
                txType = "ðŸ”„ Self / Fee";
              }

              return {
                txid: tx.txid,
                type: txType,
                value: valueDisplay,
                time: tx.formattedTime || "Unknown",
                confirmations: tx.confirmations || 0,
                link: `https://blockchair.com/dogecoin/transaction/${tx.txid}`,
              };
            });
            const currentPage = Math.floor(currentTxOffset / txPerPage) + 1;
            const totalPages = Math.ceil(totalTxCount / txPerPage);

            // formatted output
            let outputHtml = `<h3>Transactions for ${currentTxAddress}</h3>
              <p>Showing transactions ${currentTxOffset + 1}-${Math.min(
              currentTxOffset + result.transactions.length,
              totalTxCount
            )} of ${totalTxCount}</p>
              <table style="width:100%; border-collapse:collapse;">
                <thead>
                  <tr>
                    <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Type</th>
                    <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Amount</th>
                    <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Date</th>
                    <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">TxID</th>
                  </tr>
                </thead>
                <tbody>`;

            displayTransactions.forEach((tx) => {
              let rowColor = "";
              if (tx.value.includes("+")) rowColor = "color:green;";
              else if (tx.value.includes("-")) rowColor = "color:red;";

              outputHtml += `
                <tr>
                  <td style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">${tx.type}</td>
                  <td style="text-align:left; padding:8px; border-bottom:1px solid #ddd; ${rowColor}">${tx.value}</td>
                  <td style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">${tx.time}</td>
                  <td style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">
                    <a href="${tx.link}" target="_blank">${tx.txid}</a>
                  </td>
                </tr>`;
            });

            outputHtml += `
                </tbody>
              </table>`;

            document.getElementById("txHistoryResult").innerHTML = outputHtml;

            // Show pagination controls if we have more than one page
            if (totalTxCount > txPerPage) {
              document.getElementById("txPagination").style.display = "flex";
              updatePaginationControls();
            }
          })
          .catch((error) => {
            console.error("Transaction error:", error);
            document.getElementById("txHistoryResult").innerText =
              "Error: " + (error.message || "Failed to fetch transactions");
          });
      }

      // Send Dogecoin using RPC method
      function sendDogeRPC() {
        const senderAddress = document
          .getElementById("senderAddress")
          .value.trim();
        const privateKey = document.getElementById("privateKey").value.trim();
        const receiverAddress = document
          .getElementById("receiverAddress")
          .value.trim();
        const sendAmount = parseFloat(
          document.getElementById("sendAmount").value
        );

        if (
          !senderAddress ||
          !privateKey ||
          !receiverAddress ||
          isNaN(sendAmount) ||
          sendAmount <= 0
        ) {
          document.getElementById("sendResult").innerText =
            "Error: Please fill in all fields with valid values";
          return;
        }

        document.getElementById("sendResult").innerText =
          "Processing transaction...";

        floBlockchainAPI
          .sendDogecoinRPC(
            senderAddress,
            receiverAddress,
            sendAmount,
            privateKey
          )
          .then((txid) => {
            document.getElementById(
              "sendResult"
            ).innerHTML = `<p>Transaction successful!</p>
              <p>Transaction ID: <a href="https://blockchair.com/dogecoin/transaction/${txid}" target="_blank">${txid}</a></p>`;
          })
          .catch((error) => {
            document.getElementById("sendResult").innerText =
              "Transaction failed: " + (error.message || error);
            console.error("Transaction error:", error);
          });
      }

      // Pagination functions for transaction history
      function loadPreviousTransactions() {
        if (currentTxOffset >= txPerPage) {
          currentTxOffset -= txPerPage;
          fetchTransactionsWithPagination();
        }
      }

      function loadNextTransactions() {
        if (currentTxOffset + txPerPage < totalTxCount) {
          currentTxOffset += txPerPage;
          fetchTransactionsWithPagination();
        }
      }

      function updatePaginationControls() {
        const currentPage = Math.floor(currentTxOffset / txPerPage) + 1;
        const totalPages = Math.ceil(totalTxCount / txPerPage);

        document.getElementById(
          "txPageInfo"
        ).textContent = `Page ${currentPage} of ${totalPages}`;

        // Enable/disable buttons based on current position
        document.getElementById("prevTxButton").disabled =
          currentTxOffset === 0;
        document.getElementById("nextTxButton").disabled =
          currentTxOffset + txPerPage >= totalTxCount;
      }
    </script>
  </body>
</html>
